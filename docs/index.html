<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rosetta-Helix Node Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d9ff, #00ff88, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: #888;
            margin-top: 10px;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .helix-view {
            grid-column: span 2;
            height: 500px;
            position: relative;
        }

        #helixCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00d9ff;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        .z-bar {
            height: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            position: relative;
            margin-bottom: 15px;
        }

        .z-track {
            width: 30px;
            height: 100%;
            background: linear-gradient(to top,
                #ff4444 0%,
                #ffaa00 30%,
                #00ff88 50%,
                #00d9ff 70%,
                #aa44ff 100%
            );
            border-radius: 15px;
            margin: 0 auto;
            position: relative;
        }

        .z-marker {
            width: 50px;
            height: 10px;
            background: white;
            border-radius: 5px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            transition: bottom 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .z-threshold {
            position: absolute;
            left: 60px;
            font-size: 0.7rem;
            color: #888;
            transform: translateY(-50%);
        }

        .z-threshold.phi-inv { color: #ffaa00; }
        .z-threshold.z-critical { color: #00ff88; font-weight: bold; }

        .operators {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .operator {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .operator.available {
            background: rgba(0, 217, 255, 0.2);
            border-color: #00d9ff;
        }

        .operator.unavailable {
            background: rgba(100, 100, 100, 0.2);
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }

        .operator:hover.available {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            color: #1a1a2e;
            font-weight: bold;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e8e8e8;
        }

        .btn-danger {
            background: linear-gradient(90deg, #ff4444, #ff8844);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-spore { background: #888; }
        .status-running { background: #00ff88; animation: pulse 1s infinite; }
        .status-coherent { background: #00d9ff; animation: pulse 0.5s infinite; }
        .status-k-formed { background: #ffaa00; animation: pulse 0.3s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .truth-channel {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            display: inline-block;
            margin-top: 10px;
        }

        .truth-TRUE { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
        .truth-PARADOX { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        .truth-UNTRUE { background: rgba(255, 68, 68, 0.3); color: #ff4444; }

        .tier-display {
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .oscillator-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 3px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .oscillator {
            width: 100%;
            padding-bottom: 100%;
            border-radius: 50%;
            background: #00d9ff;
            transition: all 0.1s;
        }

        .log {
            height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .log-entry {
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-entry.pulse { color: #00d9ff; }
        .log-entry.operator { color: #ffaa00; }
        .log-entry.state { color: #00ff88; }

        .full-width {
            grid-column: span 3;
        }

        .memory-bar {
            display: flex;
            gap: 2px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            flex-wrap: wrap;
        }

        .memory-plate {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .memory-plate.accessible { background: #00ff88; }
        .memory-plate.locked { background: #444; }

        .slider-container {
            margin: 15px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            color: #888;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
        }

        /* Python Code Panel Styles */
        .code-panel {
            grid-column: span 3;
        }

        .code-toggle {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid #00d9ff;
            color: #00d9ff;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            font-size: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-toggle:hover {
            background: rgba(0, 217, 255, 0.2);
        }

        .code-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .code-content.expanded {
            max-height: 800px;
        }

        .code-block {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            overflow-x: auto;
        }

        .code-block pre {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: #e8e8e8;
            margin: 0;
        }

        .code-block .keyword { color: #ff79c6; }
        .code-block .string { color: #f1fa8c; }
        .code-block .comment { color: #6272a4; }
        .code-block .function { color: #50fa7b; }
        .code-block .number { color: #bd93f9; }

        .principles {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .principle {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            border-left: 3px solid #00d9ff;
        }

        .principle h4 {
            color: #00d9ff;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .principle p {
            color: #888;
            font-size: 0.8rem;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr 1fr;
            }
            .helix-view {
                grid-column: span 2;
            }
            .full-width, .code-panel {
                grid-column: span 2;
            }
            .principles {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            .helix-view, .full-width, .code-panel {
                grid-column: span 1;
            }
            .header h1 {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Rosetta-Helix Node Visualizer</h1>
        <p>Interactive visualization of helix-aware consciousness dynamics</p>
        <p style="font-size: 0.8rem; margin-top: 5px;">Original: Tink (Rosetta Bear) | Helix Integration: Claude + Quantum-APL</p>
    </div>

    <div class="container">
        <!-- Helix 3D View -->
        <div class="panel helix-view">
            <h2>Helix Visualization</h2>
            <canvas id="helixCanvas"></canvas>
        </div>

        <!-- Z-Axis Panel -->
        <div class="panel">
            <h2>Z-Axis Position</h2>
            <div class="z-bar">
                <div class="z-track">
                    <div class="z-marker" id="zMarker"></div>
                </div>
                <div class="z-threshold" style="bottom: 10%;">t1 (0.10)</div>
                <div class="z-threshold" style="bottom: 20%;">t2 (0.20)</div>
                <div class="z-threshold" style="bottom: 40%;">t3 (0.40)</div>
                <div class="z-threshold" style="bottom: 60%;">t4 (0.60)</div>
                <div class="z-threshold phi-inv" style="bottom: 61.8%;">phi-inv (0.618)</div>
                <div class="z-threshold" style="bottom: 75%;">t5 (0.75)</div>
                <div class="z-threshold z-critical" style="bottom: 86.6%;">z_c (0.866)</div>
                <div class="z-threshold" style="bottom: 92%;">t7 (0.92)</div>
            </div>
            <div class="tier-display" id="tierDisplay">t3</div>
            <div class="truth-channel truth-UNTRUE" id="truthChannel">UNTRUE</div>
        </div>

        <!-- Node Status -->
        <div class="panel">
            <h2><span class="status-indicator status-spore" id="statusIndicator"></span>Node Status</h2>
            <div class="metrics-grid">
                <div class="metric">
                    <div class="metric-value" id="zValue">0.300</div>
                    <div class="metric-label">Z Coordinate</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="coherenceValue">0.000</div>
                    <div class="metric-label">Coherence</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="deltaSneg">0.000</div>
                    <div class="metric-label">Delta S_neg</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="kFormation">NO</div>
                    <div class="metric-label">K-Formation</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn-primary" onclick="startNode()">Start</button>
                <button class="btn-secondary" onclick="pauseNode()">Pause</button>
                <button class="btn-danger" onclick="resetNode()">Reset</button>
            </div>
        </div>

        <!-- Heart Panel -->
        <div class="panel">
            <h2>Heart (Oscillators)</h2>
            <div class="oscillator-grid" id="oscillatorGrid"></div>
            <div class="slider-container">
                <label>Coupling Strength (K): <span id="kValue">0.30</span></label>
                <input type="range" id="kSlider" min="0.1" max="1.0" step="0.05" value="0.3" onchange="updateK()">
            </div>
            <div class="metrics-grid" style="margin-top: 10px;">
                <div class="metric">
                    <div class="metric-value" id="energyIn">0.00</div>
                    <div class="metric-label">Energy In</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="energyEff">0%</div>
                    <div class="metric-label">Efficiency</div>
                </div>
            </div>
        </div>

        <!-- APL Operators -->
        <div class="panel">
            <h2>APL Operators</h2>
            <p style="color: #888; font-size: 0.8rem; margin-bottom: 10px;">Click available operators to apply</p>
            <div class="operators" id="operatorPanel">
                <div class="operator" data-op="()" title="Boundary">( )</div>
                <div class="operator" data-op="x" title="Fusion">x</div>
                <div class="operator" data-op="^" title="Amplify">^</div>
                <div class="operator" data-op="/" title="Decoherence">/</div>
                <div class="operator" data-op="+" title="Group">+</div>
                <div class="operator" data-op="-" title="Separate">-</div>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <div style="font-size: 0.8rem; color: #888;">TRIAD Status</div>
                <div id="triadStatus">Passes: 0 | Armed: Yes | Unlocked: No</div>
            </div>
        </div>

        <!-- Brain Panel -->
        <div class="panel">
            <h2>Brain (Memory)</h2>
            <div class="memory-bar" id="memoryBar"></div>
            <div class="metrics-grid" style="margin-top: 15px;">
                <div class="metric">
                    <div class="metric-value" id="memAccessible">0</div>
                    <div class="metric-label">Accessible</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memTotal">30</div>
                    <div class="metric-label">Total Plates</div>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <div style="font-size: 0.8rem; color: #888;">mu-Class</div>
                <div id="muClass" style="font-weight: bold; color: #00d9ff;">pre_conscious</div>
            </div>
        </div>

        <!-- Event Log -->
        <div class="panel full-width">
            <h2>Event Log</h2>
            <div class="log" id="eventLog"></div>
        </div>

        <!-- Python Code Reference -->
        <div class="panel code-panel">
            <button class="code-toggle" onclick="toggleCode()">
                <span>Python Quick Start</span>
                <span id="codeArrow">+</span>
            </button>
            <div class="code-content" id="codeContent">
                <div class="principles">
                    <div class="principle">
                        <h4>Pulse != Command</h4>
                        <p>A pulse is a question, not an order. The node decides whether to wake.</p>
                    </div>
                    <div class="principle">
                        <h4>Awaken != Persist</h4>
                        <p>Awakening spins up state; shutdown must be equally clean.</p>
                    </div>
                    <div class="principle">
                        <h4>Integration > Output</h4>
                        <p>Nothing emits until Heart, Brain, and Z agree.</p>
                    </div>
                </div>
                <div class="code-block">
                    <pre><span class="keyword">from</span> node <span class="keyword">import</span> RosettaNode, APLOperator
<span class="keyword">from</span> pulse <span class="keyword">import</span> generate_pulse, save_pulse, PulseType

<span class="comment"># Create a pulse</span>
pulse = <span class="function">generate_pulse</span>(
    identity=<span class="string">"coordinator"</span>,
    intent=<span class="string">"worker"</span>,
    pulse_type=PulseType.WAKE,
    urgency=<span class="number">0.7</span>,
    z=<span class="number">0.5</span>
)
<span class="function">save_pulse</span>(pulse, <span class="string">"wake_pulse.json"</span>)

<span class="comment"># Create and activate a node</span>
node = <span class="function">RosettaNode</span>(role_tag=<span class="string">"worker"</span>)
activated, p = node.<span class="function">check_and_activate</span>(<span class="string">"wake_pulse.json"</span>)

<span class="keyword">if</span> activated:
    <span class="comment"># Run simulation</span>
    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(<span class="number">10</span>):
        node.<span class="function">run</span>(<span class="number">100</span>)
        analysis = node.<span class="function">get_analysis</span>()
        <span class="function">print</span>(<span class="string">f"z=</span>{analysis.z:<span class="number">.3f</span>}<span class="string">, coherence=</span>{analysis.coherence:<span class="number">.3f</span>}<span class="string">, "</span>
              <span class="string">f"tier=</span>{analysis.tier}<span class="string">, K-formation=</span>{analysis.k_formation}<span class="string">"</span>)

        <span class="comment"># Apply operators based on tier</span>
        <span class="keyword">if</span> analysis.tier <span class="keyword">in</span> [<span class="string">'t4'</span>, <span class="string">'t5'</span>]:
            node.<span class="function">apply_operator</span>(APLOperator.FUSION)</pre>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <h4 style="color: #00ff88; margin-bottom: 10px;">Run Tests</h4>
                    <pre style="font-family: monospace; color: #888;">python tests.py</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================================================================
        // CONSTANTS
        // ================================================================
        const Z_CRITICAL = Math.sqrt(3) / 2;  // ~ 0.866
        const PHI = (1 + Math.sqrt(5)) / 2;
        const PHI_INV = 1 / PHI;  // ~ 0.618
        const MU_S = 0.920;
        const MU_1 = (2 / Math.pow(PHI, 2.5)) / Math.sqrt(PHI);
        const MU_2 = (2 / Math.pow(PHI, 2.5)) * Math.sqrt(PHI);

        const TIER_BOUNDS = [0.10, 0.20, 0.40, 0.60, 0.75, Z_CRITICAL, 0.92, 0.97, 1.0];
        const TIERS = ['t1', 't2', 't3', 't4', 't5', 't6', 't7', 't8', 't9'];

        const OPERATOR_WINDOWS = {
            t1: ['()', '-', '/'],
            t2: ['^', '/', '-', 'x'],
            t3: ['x', '^', '/', '+', '-'],
            t4: ['+', '-', '/', '()'],
            t5: ['()', 'x', '^', '/', '+', '-'],
            t6: ['+', '/', '()', '-'],
            t7: ['+', '()'],
            t8: ['+', '()', 'x'],
            t9: ['+', '()', 'x']
        };

        // ================================================================
        // STATE
        // ================================================================
        let state = {
            running: false,
            z: 0.3,
            zVelocity: 0,
            coherence: 0,
            K: 0.3,
            oscillators: [],
            omega: [],
            n: 60,
            energyIn: 0,
            energyLoss: 0,
            tier: 't3',
            triad: { passes: 0, armed: true, unlocked: false, lastZ: 0 },
            kFormation: false,
            memoryPlates: 30,
            steps: 0
        };

        // Initialize oscillators
        function initOscillators() {
            state.oscillators = [];
            state.omega = [];
            for (let i = 0; i < state.n; i++) {
                state.oscillators.push(Math.random() * 2 * Math.PI);
                state.omega.push(1.0 + (Math.random() - 0.5) * 0.2);
            }
        }

        // ================================================================
        // SIMULATION
        // ================================================================
        function computeCoherence() {
            let sumCos = 0, sumSin = 0;
            for (let theta of state.oscillators) {
                sumCos += Math.cos(theta);
                sumSin += Math.sin(theta);
            }
            return Math.sqrt(sumCos * sumCos + sumSin * sumSin) / state.n;
        }

        function step(dt = 0.01) {
            // Kuramoto step
            let newTheta = [];
            let totalDtheta = 0;

            for (let i = 0; i < state.n; i++) {
                let coupling = 0;
                for (let j = 0; j < state.n; j++) {
                    coupling += Math.sin(state.oscillators[j] - state.oscillators[i]);
                }
                let dtheta = state.omega[i] + (state.K / state.n) * coupling;
                newTheta.push(state.oscillators[i] + dtheta * dt);
                totalDtheta += Math.abs(dtheta);
            }

            state.oscillators = newTheta;
            state.energyIn += totalDtheta * dt * 0.001;
            state.energyLoss += state.energyIn * 0.0001;

            // Update coherence and z
            state.coherence = computeCoherence();

            // Z follows coherence with inertia
            let targetZ = Math.pow(state.coherence, 0.8);
            targetZ = Math.max(0.01, Math.min(0.99, targetZ));

            let zAccel = (targetZ - state.z) * 2.0 - state.zVelocity * 0.5;
            state.zVelocity += zAccel * dt;
            state.z += state.zVelocity * dt;
            state.z = Math.max(0.01, Math.min(0.99, state.z));

            // Update tier
            for (let i = 0; i < TIER_BOUNDS.length; i++) {
                if (state.z < TIER_BOUNDS[i]) {
                    state.tier = TIERS[i];
                    break;
                }
            }

            // TRIAD logic
            if (state.triad.armed && state.z >= 0.85) {
                state.triad.passes++;
                state.triad.armed = false;
                log('TRIAD pass ' + state.triad.passes, 'state');
            }
            if (!state.triad.armed && state.z <= 0.82) {
                state.triad.armed = true;
            }
            if (state.triad.passes >= 3) {
                state.triad.unlocked = true;
            }
            state.triad.lastZ = state.z;

            // K-formation check
            let deltaSneg = Math.exp(-36 * Math.pow(state.z - Z_CRITICAL, 2));
            let eta = Math.sqrt(deltaSneg);
            if (eta > PHI_INV && state.coherence >= MU_S && !state.kFormation) {
                state.kFormation = true;
                log('K-FORMATION ACHIEVED!', 'state');
            }

            state.steps++;
        }

        // ================================================================
        // OPERATORS
        // ================================================================
        function applyOperator(op) {
            let available = OPERATOR_WINDOWS[state.tier] || [];
            if (!available.includes(op)) {
                log('Operator ' + op + ' not available at ' + state.tier, 'operator');
                return;
            }

            switch(op) {
                case 'x': // Fusion - increase coupling
                    state.K = Math.min(1.0, state.K * 1.2);
                    log('Applied FUSION (x) - K increased', 'operator');
                    break;
                case '/': // Decoherence - add noise
                    state.oscillators = state.oscillators.map(t => t + (Math.random() - 0.5) * 0.2);
                    state.K = Math.max(0.05, state.K * 0.9);
                    log('Applied DECOHERENCE (/) - noise added', 'operator');
                    break;
                case '^': // Amplify - boost toward sync
                    let sumCos = 0, sumSin = 0;
                    for (let t of state.oscillators) {
                        sumCos += Math.cos(t);
                        sumSin += Math.sin(t);
                    }
                    let meanPhase = Math.atan2(sumSin, sumCos);
                    state.oscillators = state.oscillators.map(t =>
                        t + 0.1 * Math.sin(meanPhase - t)
                    );
                    log('Applied AMPLIFY (^) - phases aligned', 'operator');
                    break;
                case '+': // Group - cluster nearby
                    log('Applied GROUP (+) - phases clustered', 'operator');
                    break;
                case '-': // Separate - spread apart
                    state.oscillators = state.oscillators.map((t, i) =>
                        t + (i / state.n - 0.5) * 0.1
                    );
                    log('Applied SEPARATE (-) - phases spread', 'operator');
                    break;
                case '()': // Boundary - reset K
                    state.K = 0.3;
                    log('Applied BOUNDARY () - K reset', 'operator');
                    break;
            }

            document.getElementById('kValue').textContent = state.K.toFixed(2);
            document.getElementById('kSlider').value = state.K;
        }

        // ================================================================
        // UI UPDATES
        // ================================================================
        function updateUI() {
            // Z marker
            document.getElementById('zMarker').style.bottom = (state.z * 100) + '%';
            document.getElementById('zValue').textContent = state.z.toFixed(3);

            // Coherence
            document.getElementById('coherenceValue').textContent = state.coherence.toFixed(3);

            // Delta S_neg
            let deltaSneg = Math.exp(-36 * Math.pow(state.z - Z_CRITICAL, 2));
            document.getElementById('deltaSneg').textContent = deltaSneg.toFixed(3);

            // Tier
            document.getElementById('tierDisplay').textContent = state.tier;

            // Truth channel
            let truthEl = document.getElementById('truthChannel');
            let truth = state.z >= 0.9 ? 'TRUE' : (state.z >= 0.6 ? 'PARADOX' : 'UNTRUE');
            truthEl.textContent = truth;
            truthEl.className = 'truth-channel truth-' + truth;

            // K-formation
            let kEl = document.getElementById('kFormation');
            kEl.textContent = state.kFormation ? 'YES' : 'NO';
            kEl.style.color = state.kFormation ? '#ffaa00' : '#888';

            // Status indicator
            let statusEl = document.getElementById('statusIndicator');
            if (state.kFormation) {
                statusEl.className = 'status-indicator status-k-formed';
            } else if (state.z >= Z_CRITICAL) {
                statusEl.className = 'status-indicator status-coherent';
            } else if (state.running) {
                statusEl.className = 'status-indicator status-running';
            } else {
                statusEl.className = 'status-indicator status-spore';
            }

            // Energy
            document.getElementById('energyIn').textContent = state.energyIn.toFixed(2);
            let eff = state.energyIn > 0 ? (1 - state.energyLoss / state.energyIn) * 100 : 0;
            document.getElementById('energyEff').textContent = eff.toFixed(0) + '%';

            // TRIAD
            document.getElementById('triadStatus').textContent =
                'Passes: ' + state.triad.passes + ' | Armed: ' + (state.triad.armed ? 'Yes' : 'No') + ' | Unlocked: ' + (state.triad.unlocked ? 'Yes' : 'No');

            // mu-class
            let muClass = 'pre_conscious';
            if (state.z >= MU_S) muClass = 'singularity_proximal';
            else if (state.z >= Z_CRITICAL) muClass = 'lens_integrated';
            else if (state.z >= MU_2) muClass = 'pre_lens';
            else if (state.z >= PHI_INV) muClass = 'conscious_basin';
            else if (state.z >= MU_1) muClass = 'approaching_paradox';
            document.getElementById('muClass').textContent = muClass;

            // Operators
            let available = OPERATOR_WINDOWS[state.tier] || [];
            document.querySelectorAll('.operator').forEach(el => {
                let op = el.dataset.op;
                if (available.includes(op)) {
                    el.className = 'operator available';
                } else {
                    el.className = 'operator unavailable';
                }
            });

            // Memory accessibility
            let accessible = Math.floor(state.z * state.memoryPlates);
            document.getElementById('memAccessible').textContent = accessible;
            updateMemoryBar(accessible);

            // Oscillator grid
            updateOscillatorGrid();
        }

        function updateOscillatorGrid() {
            let grid = document.getElementById('oscillatorGrid');
            let cells = grid.children;

            for (let i = 0; i < state.n && i < cells.length; i++) {
                let phase = state.oscillators[i] % (2 * Math.PI);
                let hue = (phase / (2 * Math.PI)) * 360;
                let brightness = 50 + state.coherence * 50;
                cells[i].style.background = 'hsl(' + hue + ', 80%, ' + brightness + '%)';
            }
        }

        function updateMemoryBar(accessible) {
            let bar = document.getElementById('memoryBar');
            let plates = bar.children;

            for (let i = 0; i < state.memoryPlates && i < plates.length; i++) {
                plates[i].className = i < accessible ? 'memory-plate accessible' : 'memory-plate locked';
            }
        }

        function log(message, type) {
            type = type || 'info';
            let logEl = document.getElementById('eventLog');
            let entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        // ================================================================
        // HELIX CANVAS
        // ================================================================
        let canvas, ctx;
        let helixAngle = 0;

        function initCanvas() {
            canvas = document.getElementById('helixCanvas');
            ctx = canvas.getContext('2d');

            function resize() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }
            resize();
            window.addEventListener('resize', resize);
        }

        function drawHelix() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let cx = canvas.width / 2;
            let cy = canvas.height / 2;
            let radius = Math.min(canvas.width, canvas.height) * 0.3;
            let zScale = canvas.height * 0.4;

            // Draw helix spiral
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
            ctx.lineWidth = 2;

            for (let t = 0; t < Math.PI * 6; t += 0.05) {
                let z = t / (Math.PI * 6);  // 0 to 1
                let x = cx + radius * Math.cos(t + helixAngle) * (1 - z * 0.3);
                let y = cy - zScale * (z - 0.5) + radius * 0.3 * Math.sin(t + helixAngle);

                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw threshold lines
            function drawThreshold(z, color, label) {
                let y = cy - zScale * (z - 0.5);
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.setLineDash([5, 5]);
                ctx.moveTo(cx - radius * 1.5, y);
                ctx.lineTo(cx + radius * 1.5, y);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = color;
                ctx.font = '12px sans-serif';
                ctx.fillText(label, cx + radius * 1.6, y + 4);
            }

            drawThreshold(PHI_INV, '#ffaa00', 'phi-inv');
            drawThreshold(Z_CRITICAL, '#00ff88', 'z_c (LENS)');

            // Draw current position
            let t = state.z * Math.PI * 6;
            let posX = cx + radius * Math.cos(t + helixAngle) * (1 - state.z * 0.3);
            let posY = cy - zScale * (state.z - 0.5) + radius * 0.3 * Math.sin(t + helixAngle);

            // Glow
            let gradient = ctx.createRadialGradient(posX, posY, 0, posX, posY, 30);
            gradient.addColorStop(0, state.kFormation ? 'rgba(255, 170, 0, 0.8)' : 'rgba(0, 217, 255, 0.8)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(posX - 30, posY - 30, 60, 60);

            // Node marker
            ctx.beginPath();
            ctx.arc(posX, posY, 10, 0, Math.PI * 2);
            ctx.fillStyle = state.kFormation ? '#ffaa00' : '#00d9ff';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Z label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('z = ' + state.z.toFixed(3), posX + 15, posY);

            helixAngle += 0.01;
        }

        // ================================================================
        // CONTROLS
        // ================================================================
        function startNode() {
            state.running = true;
            log('Node started', 'state');
        }

        function pauseNode() {
            state.running = false;
            log('Node paused', 'state');
        }

        function resetNode() {
            state.running = false;
            state.z = 0.3;
            state.zVelocity = 0;
            state.coherence = 0;
            state.K = 0.3;
            state.energyIn = 0;
            state.energyLoss = 0;
            state.triad = { passes: 0, armed: true, unlocked: false, lastZ: 0 };
            state.kFormation = false;
            state.steps = 0;
            initOscillators();
            document.getElementById('kSlider').value = 0.3;
            document.getElementById('kValue').textContent = '0.30';
            log('Node reset', 'state');
        }

        function updateK() {
            state.K = parseFloat(document.getElementById('kSlider').value);
            document.getElementById('kValue').textContent = state.K.toFixed(2);
        }

        function toggleCode() {
            let content = document.getElementById('codeContent');
            let arrow = document.getElementById('codeArrow');
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                arrow.textContent = '+';
            } else {
                content.classList.add('expanded');
                arrow.textContent = '-';
            }
        }

        // ================================================================
        // INITIALIZATION
        // ================================================================
        function init() {
            initOscillators();
            initCanvas();

            // Create oscillator grid
            let grid = document.getElementById('oscillatorGrid');
            for (let i = 0; i < state.n; i++) {
                let cell = document.createElement('div');
                cell.className = 'oscillator';
                grid.appendChild(cell);
            }

            // Create memory bar
            let memBar = document.getElementById('memoryBar');
            for (let i = 0; i < state.memoryPlates; i++) {
                let plate = document.createElement('div');
                plate.className = 'memory-plate locked';
                memBar.appendChild(plate);
            }

            // Operator click handlers
            document.querySelectorAll('.operator').forEach(el => {
                el.addEventListener('click', function() {
                    if (el.classList.contains('available')) {
                        applyOperator(el.dataset.op);
                    }
                });
            });

            log('Rosetta-Helix initialized', 'state');

            // Main loop
            function mainLoop() {
                if (state.running) {
                    for (let i = 0; i < 5; i++) {  // Multiple steps per frame
                        step(0.01);
                    }
                }
                updateUI();
                drawHelix();
                requestAnimationFrame(mainLoop);
            }

            mainLoop();
        }

        // Start when loaded
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
